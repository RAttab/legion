/* db_types.c
   RÃ©mi Attab (remi.attab@gmail.com), 12 Jun 2023
   FreeBSD-style copyright and disclaimer apply
*/


// -----------------------------------------------------------------------------
// info
// -----------------------------------------------------------------------------

enum db_order
{
    order_first,
    order_nil,
    order_last,
};

enum db_list
{
    list_nil = 0,
    list_control,
    list_factory,
};

struct db_info
{
    int8_t layer; // signed to make sorting arithmetics easier in db_gen_items
    enum im_type type;
    enum db_order order;
    enum db_list list;
    struct symbol name, config;
    int64_t atom;
};

#define vecx_type struct db_info
#define vecx_name vec_info
#define vecx_sort_fn
#include "utils/vecx.h"


// -----------------------------------------------------------------------------
// file
// -----------------------------------------------------------------------------

struct db_file
{
    char path[PATH_MAX];
    struct mfilew mfile;
    char *it, *end;
};

#define db_file_write(_f, _str)                         \
    do {                                                \
        struct db_file *f = (_f);                       \
        f->it += snprintf(f->it, f->end - f->it, _str); \
        assert(f->it < f->end);                         \
    } while (false)

#define db_file_writef(_f, _fmt, ...)                                   \
    do {                                                                \
        struct db_file *f = (_f);                                       \
        f->it += snprintf(f->it, f->end - f->it, _fmt, __VA_ARGS__);    \
        assert(f->it < f->end);                                         \
    } while (false)

#define db_file_write_sep(_f, _name)                                    \
    db_file_writef(_f,                                                  \
            "\n"                                                        \
            "// -----------------------------------------------------------------------------\n" \
            "// %s\n"                                                   \
            "// -----------------------------------------------------------------------------\n" \
            "\n", _name)                                                \

void db_file_open(struct db_file *file, const char *dir, const char *name)
{
    // I can't be bothered...
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wformat-truncation"
    snprintf(file->path, sizeof(file->path), "%s/%s.h", dir, name);
    #pragma GCC diagnostic pop

    file->mfile = mfilew_create_tmp(file->path, 1048576);
    file->it = file->mfile.ptr;
    file->end = file->it + file->mfile.len;

    db_file_write(file,
            "/* This file was generated by ./gen --db */\n"
            "#pragma once\n\n");
}

void db_file_close(struct db_file *file)
{
    assert(file->it < file->end);

    size_t len = file->it - file->mfile.ptr;
    mfilew_close(&file->mfile);
    file_tmp_swap(file->path);
    file_truncate(file->path, len);
}


// -----------------------------------------------------------------------------
// state
// -----------------------------------------------------------------------------

struct db_state
{
    struct {
        char stars[PATH_MAX];
        char in[PATH_MAX];
        char io[PATH_MAX];
        char out[PATH_MAX];
    } path;

    struct { struct htable name; struct symbol value[UINT8_MAX]; } atoms;
    struct vec_info *info;

    struct {
        struct db_file im_enum, im_register, im_includes;
        struct db_file im_control, im_factory;
        struct db_file specs_enum, specs_value, specs_register;
        struct db_file tapes, tapes_info;
        struct db_file io_enum, ioe_enum, io_register;
        struct db_file stars_prefix, stars_suffix, stars_rolls;
    } files;
};

bool state_atoms_set(struct db_state *state, struct symbol *name, uint64_t value) {
    hash_val key = symbol_hash(name);
    struct htable_ret ret = htable_put(&state->atoms.name, key, value);
    if (!ret.ok) return false;

    assert(value < array_len(state->atoms.value));
    state->atoms.value[value] = *name;
    return true;
}

uint64_t state_atoms_value(struct db_state *state, struct symbol *name) {
    hash_val key = symbol_hash(name);
    struct htable_ret ret = htable_get(&state->atoms.name, key);
    return ret.ok ? ret.value : 0;
}

struct symbol state_atoms_name(struct db_state *state, uint64_t value) {
    assert(value < array_len(state->atoms.value));
    return state->atoms.value[value];
}
