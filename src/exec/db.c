/* gen.c
   RÃ©mi Attab (remi.attab@gmail.com), 18 Oct 2022
   FreeBSD-style copyright and disclaimer apply
*/

#include "common.h"
#include "vm/atoms.h"
#include "utils/fs.h"
#include "utils/config.h"

// -----------------------------------------------------------------------------
// info
// -----------------------------------------------------------------------------

enum db_type
{
    type_nil = 0,
    type_natural,
    type_synth,
    type_passive,
    type_active,
    type_logistics,
    type_sys,
};

struct symbol db_type_sym(enum db_type type)
{
    switch (type)
    {
    case type_natural: { return make_symbol("natural"); }
    case type_synth: { return make_symbol("synth"); }
    case type_passive: { return make_symbol("passive"); }
    case type_active: { return make_symbol("active"); }
    case type_logistics: { return make_symbol("logistics"); }
    case type_sys: { return make_symbol("sys"); }
    case type_nil: default: { assert(false); }
    }
}

enum db_order
{
    order_first,
    order_nil,
    order_last,
};

enum db_list
{
    list_nil = 0,
    list_control,
    list_factory,
};

struct db_info
{
    enum db_type type;
    enum db_order order;
    enum db_list list;
    struct symbol name, config;
    vm_word atom;
};

#define vecx_type struct db_info
#define vecx_name vec_info
#define vecx_sort_fn
#include "utils/vecx.h"


// -----------------------------------------------------------------------------
// file
// -----------------------------------------------------------------------------

struct db_file
{
    char path[PATH_MAX];
    struct mfilew mfile;
    char *it, *end;
};

#define db_file_write(_f, _str)                         \
    do {                                                \
        struct db_file *f = (_f);                       \
        f->it += snprintf(f->it, f->end - f->it, _str); \
        assert(f->it < f->end);                         \
    } while (false)

#define db_file_writef(_f, _fmt, ...)                                   \
    do {                                                                \
        struct db_file *f = (_f);                                       \
        f->it += snprintf(f->it, f->end - f->it, _fmt, __VA_ARGS__);    \
        assert(f->it < f->end);                                         \
    } while (false)

#define db_file_write_sep(_f, _name)                                    \
    db_file_writef(_f,                                                  \
            "\n"                                                        \
            "// -----------------------------------------------------------------------------\n" \
            "// %s\n"                                                   \
            "// -----------------------------------------------------------------------------\n" \
            "\n", _name)                                                \

void db_file_open(struct db_file *file, const char *dir, const char *name)
{
    // I can't be bothered...
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wformat-truncation"
    snprintf(file->path, sizeof(file->path), "%s/%s.h", dir, name);
    #pragma GCC diagnostic pop

    file->mfile = mfilew_create_tmp(file->path, 1048576);
    file->it = file->mfile.ptr;
    file->end = file->it + file->mfile.len;

    db_file_write(file,
            "/* This file was generated by ./legion --db */\n"
            "#pragma once\n\n");
}

void db_file_close(struct db_file *file)
{
    assert(file->it < file->end);

    size_t len = file->it - file->mfile.ptr;
    mfilew_close(&file->mfile);
    file_tmp_swap(file->path);
    file_truncate(file->path, len);
}


// -----------------------------------------------------------------------------
// state
// -----------------------------------------------------------------------------

struct db_state
{
    struct {
        char in[PATH_MAX];
        char io[PATH_MAX];
        char out[PATH_MAX];
    } path;

    struct atoms *atoms;
    struct vec_info *info;

    struct {
        struct db_file im_enum, im_register, im_includes;
        struct db_file im_control, im_factory;
        struct db_file specs_enum, specs_value, specs_register;
        struct db_file tapes;
        struct db_file io_enum, ioe_enum, io_register;
    } files;
};


// -----------------------------------------------------------------------------
// misc
// -----------------------------------------------------------------------------

struct symbol symbol_to_enum(struct symbol sym)
{
    for (size_t i = 0; i < sym.len; ++i)
        if (sym.c[i] == '-') sym.c[i] = '_';
    return sym;
}


// -----------------------------------------------------------------------------
// db_parse_atoms
// -----------------------------------------------------------------------------

static void db_parse_atoms(struct db_state *state, const char *path)
{
    struct config config = {0};
    struct reader *in = config_read(&config, path);

    while (!reader_peek_eof(in)) {
        reader_open(in);

        struct db_info *info = &state->info->vals[state->info->len++];
        *info = (struct db_info) {
            .name = reader_symbol(in),
            .order = order_nil,
            .atom = 0,
        };

        reader_open(in);
        reader_symbol_str(in, "info");

        while (!reader_peek_close(in)) {
            reader_open(in);

            struct symbol field = reader_symbol(in);
            uint64_t hash = symbol_hash(&field);

            if (hash == symbol_hash_c("type")) {
                struct symbol type = reader_symbol(in);
                uint64_t hash = symbol_hash(&type);
                if (hash == symbol_hash_c("natural"))   info->type = type_natural;
                else if (hash == symbol_hash_c("synth"))     info->type = type_synth;
                else if (hash == symbol_hash_c("passive"))   info->type = type_passive;
                else if (hash == symbol_hash_c("active"))    info->type = type_active;
                else if (hash == symbol_hash_c("logistics")) info->type = type_logistics;
                else if (hash == symbol_hash_c("sys"))       info->type = type_sys;
                else reader_err(in, "unkown info type: %s", type.c);
                reader_close(in);
            }

            else if (hash == symbol_hash_c("list")) {
                struct symbol list = reader_symbol(in);
                uint64_t hash = symbol_hash(&list);
                if (hash == symbol_hash_c("nil"))   info->list = list_nil;
                else if (hash == symbol_hash_c("control")) info->list = list_control;
                else if (hash == symbol_hash_c("factory"))  info->list = list_factory;
                else reader_err(in, "unkown info list: %s", list.c);
                reader_close(in);
            }

            else if (hash == symbol_hash_c("order")) {
                struct symbol order = reader_symbol(in);
                uint64_t hash = symbol_hash(&order);
                if (hash == symbol_hash_c("nil"))   info->order = order_nil;
                else if (hash == symbol_hash_c("first")) info->order = order_first;
                else if (hash == symbol_hash_c("last"))  info->order = order_last;
                else reader_err(in, "unkown info order: %s", order.c);
                reader_close(in);
            }

            else if (hash == symbol_hash_c("config")) {
                info->config = reader_symbol(in);
                reader_close(in);
            }

            else reader_goto_close(in);

        }
        assert(info->type != type_nil);

        reader_close(in); // info

        // skip the rest of the object
        reader_goto_close(in);
    }

    config_close(&config);
}


// -----------------------------------------------------------------------------
// db_gen_items
// -----------------------------------------------------------------------------

static void db_gen_items(struct db_state *state)
{
    int cmp(const void *lhs_, const void *rhs_) {
        const struct db_info *lhs = lhs_;
        const struct db_info *rhs = rhs_;

        if (lhs->type != rhs->type) return lhs->type - rhs->type;
        if (lhs->order != rhs->order) return lhs->order - rhs->order;
        return symbol_cmp(&lhs->name, &rhs->name);
    }
    vec_info_sort_fn(state->info, cmp);

    void write_bounds_end(enum db_type type, vm_word atom) {
        struct symbol sym_type = db_type_sym(type);
        db_file_writef(&state->files.im_enum,
                "  items_%s_last = 0x%02lx,\n"
                "  items_%s_len = items_%s_last - items_%s_first,\n",
                sym_type.c, atom,
                sym_type.c, sym_type.c, sym_type.c);
    }

    enum db_type type = type_nil;
    for (size_t i = 0; i < state->info->len; ++i) {
        struct db_info *info = state->info->vals + i;

        info->atom = i + 1;
        struct symbol atom = symbol_concat("item-", info->name.c);
        bool ok = atoms_set(state->atoms, &atom, info->atom);
        if (!ok) errf("duplicate item: %s", atom.c);

        if (type != info->type) {
            if (type) write_bounds_end(type, info->atom);
            type = info->type;
            struct symbol sym_type = db_type_sym(type);
            db_file_write_sep(&state->files.im_enum, sym_type.c);
            db_file_write_sep(&state->files.im_register, sym_type.c);
            db_file_writef(&state->files.im_enum,
                    "  items_%s_first = 0x%02lx,\n", sym_type.c, info->atom);
        }

        struct symbol sym_enum = symbol_to_enum(info->name);

        db_file_writef(&state->files.im_enum,
                "  item_%-20s = 0x%02lx,\n", sym_enum.c, info->atom);

        if (info->type != type_active) {
            db_file_writef(&state->files.im_register,
                    "im_register(item_%s, \"%s\", %u, \"item-%s\"),\n",
                    sym_enum.c, info->name.c, info->name.len, info->name.c);
        }
        else if (info->config.len) {
            db_file_writef(&state->files.im_register,
                    "im_register_cfg(item_%s, \"%s\", %u, \"item-%s\", im_%s_config),\n",
                    sym_enum.c, info->name.c, info->name.len, info->name.c, info->config.c);
        }
        else {
            db_file_writef(&state->files.im_register,
                    "im_register_cfg(item_%s, \"%s\", %u, \"item-%s\", im_%s_config),\n",
                    sym_enum.c, info->name.c, info->name.len, info->name.c, sym_enum.c);
            db_file_writef(&state->files.im_includes,
                    "#include \"items/%s/%s.h\"\n", sym_enum.c, sym_enum.c);
        }

        if (info->list == list_control)
            db_file_writef(&state->files.im_control, "item_%s,\n", sym_enum.c);
        if (info->list == list_factory)
            db_file_writef(&state->files.im_factory, "item_%s,\n", sym_enum.c);

        if (i == state->info->len - 1)
            write_bounds_end(type, info->atom + 1);
    }

    db_file_writef(&state->files.im_enum,
            "\n  items_max = 0x%02x,\n", state->info->len + 1);
}


// -----------------------------------------------------------------------------
// full
// -----------------------------------------------------------------------------

static void db_gen_specs(
        struct db_state *state, struct reader *in, const struct symbol *item)
{
    struct symbol item_enum = symbol_to_enum(*item);

    uint8_t seq = 0;
    while (!reader_peek_close(in)) {
        reader_open(in);

        struct symbol spec = reader_symbol(in);
        struct symbol spec_enum = symbol_to_enum(spec);

        hash_val hash = symbol_hash(&spec);
        if (    hash == symbol_hash_c("lab-bits") ||
                hash == symbol_hash_c("lab-work") ||
                hash == symbol_hash_c("lab-energy"))
        {
            db_file_writef(&state->files.specs_enum,
                    "\nspec_%s_%s = make_spec(item_%s, spec_%s),",
                    item_enum.c, spec_enum.c, item_enum.c, spec_enum.c);
        }
        else {
            db_file_writef(&state->files.specs_enum,
                    "\nspec_%s_%s = make_spec(item_%s, 0x%x),",
                    item_enum.c, spec_enum.c, item_enum.c, seq++);
        }


        struct symbol type = reader_symbol(in);
        hash_val type_hash = symbol_hash(&type);

        if (type_hash == symbol_hash_c("fn")) {
            db_file_writef(&state->files.specs_register,
                    "spec_register_fn("
                    "spec_%s_%s, "
                    "\"spec-%s-%s\", "
                    "spec_%s_%s_fn);\n",
                    item_enum.c, spec_enum.c,
                    item->c, spec.c,
                    item_enum.c, spec_enum.c);
            reader_close(in);
            continue;
        }

        db_file_writef(&state->files.specs_register,
                "spec_register_var("
                "spec_%s_%s, "
                "\"spec-%s-%s\", "
                "im_%s_%s);\n",
                item_enum.c, spec_enum.c,
                item->c, spec.c,
                item_enum.c, spec_enum.c);

        if (type_hash == symbol_hash_c("word"))
            type = make_symbol("vm_word");

        else if (type_hash == symbol_hash_c("item"))
            type = make_symbol("enum item");

        else if (type_hash == symbol_hash_c("work"))
            type = make_symbol("im_work");

        else if (type_hash == symbol_hash_c("u8"))
            type = make_symbol("uint8_t");

        else if (type_hash == symbol_hash_c("energy"))
            type = make_symbol("im_energy");

        else {
            reader_err(in, "unknown type '%s'", type.c);
            reader_goto_close(in);
            continue;
        }

        db_file_writef(&state->files.specs_value,
                "static const %s im_%s_%s = ", type.c, item_enum.c, spec_enum.c);

        enum token_type token = reader_peek(in);
        switch (token) {
        case token_number: {
            db_file_writef(&state->files.specs_value, "0x%lx;\n", reader_word(in));
            break;
        }
        case token_atom: {
            struct symbol atom = symbol_to_enum(reader_atom_symbol(in));
            db_file_writef(&state->files.specs_value, "%s;\n", atom.c);
            break;
        }
        default: {
            reader_err(in, "unexpected token type: %s", token_type_str(token));
            reader_goto_close(in);
            continue;
        }
        }

        reader_close(in);
    }

    reader_close(in);

    db_file_write(&state->files.specs_enum, "\n");
    db_file_write(&state->files.specs_value, "\n");
    db_file_write(&state->files.specs_register, "\n");
}

static void db_gen_tape(
        struct db_state *state, struct reader *in, const struct symbol *item)
{
    uint8_t work = 0;
    im_energy energy = 0;
    struct symbol host = {0};

    size_t input = 0, output = 0;
    struct symbol tape[256] = {0};

    struct symbol item_enum = symbol_to_enum(*item);

    while (!reader_peek_close(in)) {
        reader_open(in);

        struct symbol key = reader_symbol(in);
        hash_val hash = symbol_hash(&key);

        if (hash == symbol_hash_c("work")) {
            vm_word value = reader_word(in);
            if (value < 0 || value > UINT8_MAX)
                reader_err(in, "invalid work value '%lx'", value);
            work = value;
            reader_close(in);
            continue;
        }

        else if (hash == symbol_hash_c("energy")) {
            vm_word value = reader_word(in);
            if (value < 0 || value > UINT32_MAX)
                reader_err(in, "invalid energy value '%lx'", value);
            energy = value;
            reader_close(in);
            continue;
        }

        else if (hash == symbol_hash_c("host")) {
            struct symbol value = reader_symbol(in);
            if (!atoms_get(state->atoms, &value))
                reader_err(in, "unknown host atom '%s'", value.c);
            host = symbol_to_enum(value);
            reader_close(in);
            continue;
        }

        bool is_input = hash == symbol_hash_c("in");
        bool is_output = hash == symbol_hash_c("out");
        if (!is_input && !is_output) {
            reader_err(in, "unknown field '%s'", key.c);
            reader_goto_close(in);
            continue;
        }

        while (!reader_peek_close(in)) {
            vm_word count = 1;
            struct symbol item = {0};

            if (reader_peek(in) == token_symbol)
                item = reader_symbol(in);
            else {
                reader_open(in);
                item = reader_symbol(in);
                count = reader_word(in);
                reader_close(in);
            }

            if (!atoms_get(state->atoms, &item))
                reader_err(in, "unknown atom '%s'", item.c);

            if (count < 1 || count > UINT8_MAX) {
                reader_err(in, "invalid count '%lx'", count);
                count = 0;
            }

            if (count + input + output > UINT8_MAX) {
                reader_err(in, "tape overflow: %zu + %zu + %zu", count, input, output);
                count = 0;
            }

            item = symbol_to_enum(item);
            for (size_t i = 0; i < (size_t) count; ++i) {
                if (is_input) tape[input++] = item;
                if (is_output) tape[input + output++] = item;
            }
        }

        reader_close(in);
    }
    reader_close(in);

    db_file_writef(&state->files.tapes,
            "\ntape_register_begin(item_%s, %zu) {\n"
            "    .id = item_%s,\n"
            "    .host = %s,\n"
            "    .work = %u,\n"
            "    .energy = %u,\n"
            "    .inputs = %zu,\n"
            "    .outputs = %zu,\n"
            "  };\n",
            item_enum.c, input + output,
            item_enum.c, host.c, work, energy, input, output);

    for (size_t i = 0; i < input + output; ++i) {
        db_file_writef(&state->files.tapes,
                "  tape_register_ix(%3zu, %s);\n", i, tape[i].c);
    }

    db_file_write(&state->files.tapes, "tape_register_end()\n");
}


static void db_gen_specs_tapes(struct db_state *state, const char *file)
{
    struct config config = {0};
    struct reader *in = config_read(&config, file);

    while (!reader_peek_eof(in)) {
        reader_open(in);
        struct symbol item = reader_symbol(in);

        while (!reader_peek_close(in)) {
            reader_open(in);

            struct symbol section = reader_symbol(in);
            hash_val hash = symbol_hash(&section);

            if (hash == symbol_hash_c("info"))
                reader_goto_close(in);

            else if (hash == symbol_hash_c("specs"))
                db_gen_specs(state, in, &item);

            else if (hash == symbol_hash_c("tape"))
                db_gen_tape(state, in, &item);

            else {
                reader_err(in, "unknown section: %s", section.c);
                reader_goto_close(in);
            }

        }

        reader_close(in);
    }

    config_close(&config);
}


// -----------------------------------------------------------------------------
// io
// -----------------------------------------------------------------------------

static void db_gen_io(struct db_state *state, const char *file)
{
    struct config config = {0};
    struct reader *in = config_read(&config, file);

    while (!reader_peek_eof(in)) {
        reader_open(in);
        struct symbol type = reader_symbol(in);
        hash_val hash = symbol_hash(&type);

        if (hash == symbol_hash_c("io")) {
            for (size_t i = 0; !reader_peek_close(in); i++) {
                struct symbol io = reader_symbol(in);
                struct symbol io_enum = symbol_to_enum(io);

                db_file_writef(&state->files.io_enum,
                        "%-20s = io_min + 0x%02lx,\n", io_enum.c, i);
                db_file_writef(&state->files.io_register,
                        "io_register(%s, \"%s\", %u),\n",
                        io_enum.c, io.c, io.len);
            }

            reader_close(in);
            continue;
        }

        else if (hash == symbol_hash_c("ioe")) {
            for (size_t i = 0; !reader_peek_close(in); i++) {
                struct symbol ioe = reader_symbol(in);
                struct symbol ioe_enum = symbol_to_enum(ioe);

                db_file_writef(&state->files.ioe_enum,
                        "%-20s = ioe_min + 0x%02lx,\n", ioe_enum.c, i);
                db_file_writef(&state->files.io_register,
                        "ioe_register(%s, \"%s\", %u),\n",
                        ioe_enum.c, ioe.c, ioe.len);
            }

            reader_close(in);
            continue;
        }

        else {
            reader_err(in, "unknown type io '%s'", type.c);
            reader_goto_close(in);
            continue;
        }
    }

    config_close(&config);
}



// -----------------------------------------------------------------------------
// run
// -----------------------------------------------------------------------------

bool db_run(const char *path)
{
    struct db_state state = {0};
    snprintf(state.path.in, sizeof(state.path.in), "%s/res/items", path);
    snprintf(state.path.io, sizeof(state.path.io), "%s/res/io.lisp", path);
    snprintf(state.path.out, sizeof(state.path.out), "%s/src/db/gen", path);

    state.atoms = atoms_new();
    state.info = vec_info_reserve(255);

    {
        db_file_open(&state.files.im_enum, state.path.out, "item");
        db_file_write(&state.files.im_enum,
                "enum legion_packed item\n{\n  item_nil = 0x00,\n");

        db_file_open(&state.files.im_register, state.path.out, "im_register");
        db_file_write(&state.files.im_register,
                "im_register(item_nil, \"nil\", 3, \"item-nil\"),\n");

        db_file_open(&state.files.im_includes, state.path.out, "im_includes");
        db_file_open(&state.files.im_control, state.path.out, "im_control");
        db_file_open(&state.files.im_factory, state.path.out, "im_factory");

        db_file_open(&state.files.specs_enum, state.path.out, "specs_enum");
        db_file_open(&state.files.specs_register, state.path.out, "specs_register");
        db_file_open(&state.files.specs_value, state.path.out, "specs_value");

        db_file_open(&state.files.tapes, state.path.out, "tapes");

        db_file_open(&state.files.io_enum, state.path.out, "io_enum");
        db_file_open(&state.files.ioe_enum, state.path.out, "ioe_enum");
        db_file_open(&state.files.io_register, state.path.out, "io_register");
    }

    {
        struct dir_it *it = dir_it(state.path.in);
        while (dir_it_next(it))
            db_parse_atoms(&state, dir_it_path(it));
        dir_it_free(it);
    }

    db_gen_items(&state);

    {
        struct dir_it *it = dir_it(state.path.in);
        while (dir_it_next(it))
            db_gen_specs_tapes(&state, dir_it_path(it));
        dir_it_free(it);
    }

    db_gen_io(&state, state.path.io);

    {
        db_file_write(&state.files.im_enum, "};\n");
        db_file_close(&state.files.im_enum);

        db_file_close(&state.files.im_register);

        db_file_close(&state.files.im_includes);
        db_file_close(&state.files.im_control);
        db_file_close(&state.files.im_factory);

        db_file_close(&state.files.specs_value);
        db_file_close(&state.files.specs_enum);
        db_file_close(&state.files.specs_register);

        db_file_close(&state.files.tapes);

        db_file_close(&state.files.io_enum);
        db_file_close(&state.files.ioe_enum);
        db_file_close(&state.files.io_register);

    }

    atoms_free(state.atoms);
    free(state.info);
    return true;
}
